## 연결리스트
일반적인 배열의 경우 원소를 삽입하거나 삭제할때 나머지 원소들이 밀리거나 당겨지므로 시간복잡도가 O(N)이 된다. 
따라서 삽입과 삭제를 자주해야 하는 알고리즘에서는 배열은 비효율적이라고 말할 수 있다. 
이 문제를 해결하기위한 자료구조가 바로 **연결리스트**이다. 연결리스트는 노드로 구성되며 각 노드는 데이터영역과 다음 노드로 이동하는 포인터로 구성되어 있다. 연결리스트는 이러한 노드들이 모여서 형성되는 구조이다.

## 단방향 연결 리스트
연결리스트중 가장 간단한 구조로, 연결방향이 단방향인 연결리스트이다. 비유하면 일방통행으로 볼 수 있다. 한 노드에서는 앞으로만 갈 수 있고 뒤로는 갈 수 없다.
하나의 node구조체에 data영역, 다음 노드를 가르키는 next영역이 있다고 하자. 그렇다면 두 노드를 연결하는 방법은 무엇일까
+ 연결
```c
struct node1 = node(3);
struct node2 = node(5);
node1.next = node2
```
위 코드는 간단한 수도코드이다. 위와 같이 next영역에 다음 노드를 삽입하여 두 노드를 연결할 수 있다.
+ 분리
```c
struct node1 = node(3);
struct node2 = node(5);
node1.next = null
```
위와 같이 next에 null을 삽입하면 두 노드는 분리된다.

+ head와 tail

연결리스트에서 중요한 점은 어느 노드가 출발이고 끝인지 명확해야 한다는 점이다. 따라서 첫번째 노드를 head, 마지막 노드를 tail이라고 호칭한다.

+ 노드 삽입
```c
struct new_node = node(n);
tail.next = new_node;
tail = new_node;
```
위 코드는 끝에서 노드를 삽입하는 방식이다.
```c
struct new_node = node(n);
new_node.next = head;
head = new_node;
```
위 코드는 맨 앞에 노드를 삽입하는 방식이다.
```c
struct new_node = node(n);
new_node.next = head.next;
head.next = new_node
```
위 코드는 head 앞에 노드를 삽입하는 방식이다.

+ 노드 삭제
```c
prev_node.next = next_node;
target_node.next = null;
```
삭제할 노드의 이전 노드를 삭제할 노드의 다음 노드와 연결하면 삭제 노드는 연결에서 분리된다.

+ 탐색

앞서 연결리스트는 삽입, 삭제는 O(1)만에 끝난다고 했다. 하지만 탐색은 어떨까? 배열에서 k번째 원소를 찾는 것은 O(1)만에 가능하다. 하지만 연결리스트에서는 O(N)만큼의 시간이 걸린다. head에서부터 순차적으로 갈 수 밖에 없기 때문이다. 이와같은 단점이 존재하므로 상황에 따라 주의하여 사용해야 한다.
