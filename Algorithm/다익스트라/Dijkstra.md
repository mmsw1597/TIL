### 다익스트라 알고리즘
가중치가 간선마다 다른 그래프에서는 BFS로 최단거리를 구할 수 없다. 가중치가 서로 다른 그래프에서 최단거리를 구하는 알고리즘 중 하나인 다익스트라 알고리즘이다. 다익스트라 알고리즘은
특정 시작점에서 다른 모든 정점까지의 최단거리를 각각 구해주는 알고리즘이다. 다시 말해 모든 정점에서의 최단거리를 구해주는 것은 아니다. 이 알고리즘은 다른 지점까지의 거리는
모르지만 A라는 지점까지의 최단거리는 확실히 안다는 가정하에 진행한다. 그렇다면 특정 지점까지의 거리는 A까지 거리 + A에서 특정 지점까지의 거리 로 나타낼 수 있다. <br>

우선 시작하기 앞서 1차원 거리 배열을 선언하고 모든 값을 매우 큰 값 INF로 초기화하고, 출발지의 값만 0으로 설정한다. 그리고 배열 값 중 최솟값을 골라준다. 다익스트라 알고리즘에서는
최솟값을 여러번 탐색해야 하므로 우선순위 큐를 사용하면 효율적이다. 따라서 시작할 때부터 각 정점을 모두 우선순위 큐에 넣는다. <br>

![image](https://user-images.githubusercontent.com/55936770/179965461-ee7ee597-0e37-471d-86b5-b9e268ce0005.png)<br>
위로 예시를 들자면 5번에서부터 시작할 때, 맨 처음 5번노드가 선택된다. 그러고 나서 5번은 우선순위 큐에서 빠지게 된다. 다음으로 배열을 갱신해야 하는데, 2번과 4번노드가
INF로 되어있고, 배열의 5번까지의 거리 0 + 간선 가중치를 각각 더하면 INF보다 작으므로 배열 값이 변경된다. 그러고 나서 다시 우선순위 큐에서 최솟값을 뽑는 식으로 우선순위 큐가
비어 있을 때까지 반복한다. 

### 시간복잡도
정점의 수를 V, 간선의 수를 E라고 할때 알고리즘 시간복잡도는 O(ElogV)가 된다. 이유는 다익스트라 알고리즘을 진행하면서 각 간선을 한번 씩 보게되고, 배열 값이 변하게 되면
우선순위 큐도 변경해야 하기 때문이다. 만약 우선순위 큐를 사용하지 않는다면 단순 반복문을 통해 최솟값을 찾아야 하는데 이럴 때는 O(V^2)이 걸리게 된다.

### 수도코드
```c
function dijkstra(graph, source)              // 그래프와 시작점 정보가 주어집니다.
    set Q = Queue()                           // 우선순위 큐를 만들어줍니다.

    for each vertex in graph                  // 그래프에 있는 모든 노드들에 대해
        set dist[v] = INF                     // 초기값을 전부 아주 큰 값으로 설정해주고 
        Q.push(v)                             // 우선순위큐에 각 노드를 넣어줍니다.

    set dist[source] = 0                      // 시작점에 대해서만 dist 값을 0으로 초기화해줍니다.
    while Q is not empty                      // 우선순위 큐가 비어있지 않을 때까지 반복합니다.
        set u = vertex in Q with min dist     // 우선순위 큐에서 dist값이 가장 작은 노드를 선택합니다.
        Q.remove(u)                           // 우선순위 큐에서 해당 노드를 제거해줍니다.

        for each neighbor v of u              // u번 노드와 연결된 노드들을 전부 살펴보면서
            set alt = dist[u] + length(u, v)  // 현재 dist값에 간선 가중치를 더한 값을 계산하여
            if alt < dist[v]                  // 기존 dist값보다 더 alt값이 작다면
                set dist[v] = alt             // dist값을 갱신해줍니다.
```
