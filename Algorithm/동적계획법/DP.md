### 동적계획법
DP라고 불리는 동적계획법은 큰 문제에 대한 답을 얻기 위해 작은 문제들을 먼저 해결하고 그 결과들을 바탕으로 큰 문제를 해결하는 기법을 의미한다. 반복문을 사용해서 풀거나,
재귀함수를 사용해서 푸는 방법이 존재한다. 가장 중요한 것은 점화식이다. 점화식은 DP문제를 해결하기 위한 핵심적인 요소이다.

### 점화식
+ F(N) = F(n-1) * N (1부터 N까지 숫자의 곱을 구하는 점화식)<br>

### 메모이제이션
작은 문제를 바탕으로 큰 문제를 해결하는 DP의 특성상 작은 문제의 결과들을 어딘가에 저장할 필요가 있다. 결과를 기록하고 기록한 값을 참조하는 것을 메모이제이션이라고 한다.
메모이제이션의 경우는 n번째 결과를 구하기 위해 높은 수에서 낮은 수로 내려가기 때문에 탑다운 방식이라고 부르며 보통 재귀함수를 사용한다.

### Tabulation
Tabulation의 경우는 반복문을 통해 낮은 수부터 값을 채워나가며 큰 수로 도달하는 방식을 말한다. 따라서 바텀업 방식이라고 부른다. 실제 재귀함수의 함수 처리의 추가적인 시간이
붙지 않아서 탑다운 방식보다 일반적으로는 빠르나 특정 문제의 경우는 탑다운/바텀업 중 한 방법으로 푸는 것이 더 쉬운 경우가 존재하므로 두 방법 모두 익히는 것이 좋다.

### 파도반 수열
![image](https://user-images.githubusercontent.com/55936770/179169006-7520d3c2-f7c2-470b-83e3-87ae19ab8d59.png)<br>
N번째의 삼각형 길이를 구하는 점화식은?

### 2*N 타일 채우기
2 x N크기의 벽을 2x1, 1x2타일로 채우는 상황일때, 채우는 방법의 경우의 수를 구하기위한 점화식은?

### BST 개수 구하기
1~N까지의 숫자를 갖고 있는 노드로 노드 개수가 N인 BST의 개수를 구하는 점화식은?

### 2*N 타일 채우기(2)
2 x N크기의 벽을 2x1, 1x2, 2x2타일로 채우는 상황일때, 채우는 방법의 경우의 수를 구하기 위한 점화식은?

### 이동하면서 최대 합 구하기
![image](https://user-images.githubusercontent.com/55936770/179171374-c365aee0-f114-4502-ae67-ccb5533612dd.png)<br>
다음과 같이 최상단에서 시작하여 최하단으로 이동했을 때 최대합을 구하기 위한 점화식은? 단, 이동방향은 위에서 바로 밑으로, 혹은 위에서 오른쪽 대각선 방향으로 1칸씩밖에 이동불가

### LIS
가장 긴 증가 부분 수열을 의미하는 LIS의 길이를 구하려고 한다. 이때 점화식은?

### 동전 거슬러 주기
예를 들어 가치가 1, 4, 5인 3개의 동전이 주어졌을 때, 금액 8을 거슬러 주기 위해 필요한 최소 동전의 수를 구하기 위한 점화식?

### Knapsack
도둑이 보석을 털려고 한다. 가방이 담을 수 있는 무게 양은 정해져 있고, 이보다 더 많은 양의 무게는 담아 나올 수 없다. 보석은 종류별로 단 하나씩 존재하며 각 보석마다
정해진 무게와 가격이 있다. 이때 가격을 가장 높게 가져갈 수 있는 방법을 구하기 위한 점화식은?

### 숫자 암호 만들기
숫자를 1, 2, 3, 4 의 합으로 바꾼다. 그리고 숫자의 합에서 사용된 숫자를 일렬로 나열한다. 예를 들어 1+1+1+1 -> 1111, 1+1+2->112 방식으로 4를 활용하면 총 8가지 경우의
수가 나온다. 이때 N을 활용하여 만들 수 있는 암호의 수를 구하기 위한 점화식은?

### LCS
최장 공통 부분 수열 LCS의 길이를 구하려고 한다. 예를들어 ABABA, BAAB의 LCS는 BAB이다. 이때 LCS길이를 구하는 점화식은?

### 편집 거리 구하기
문자열 A, B가 존재할때 A를 B로 바꾸려고 한다. 이때 가능한 최소 연산은 하나의 문자를 원하는 위치에 삽입하거나, 특정 문자를 삭제하는 연산만 존재한다. A를 B로 바꾸는데 필요한
최소 연산 횟수를 편집 거리라고 한다. 이때 편집 거리를 구하기 위한 점화식은?

### 편집 거리 구하기(2)
위 문제에서 연산하나가 추가되는데 하나의 문자를 다른 문자로 변환하는 연산이 추가된다면 이때 편집 거리를 구하기 위한 점화식은?

### 점화식 답
1. DP[n] = DP[n-2] + DP[n-3]
2. DP[n] = DP[n-1] + DP[n-2] (경우의 수를 나누는 것이 포인트 마지막에 2x1타일을 추가할 건지, 1x2타일을 추가할 건지 생각하면 된다.)
3. DP[n] += i=0 ... n-1 (DP[i] x DP[n-i-1]) (루트 노드에 1~n까지 넣어보며 경우의 수를 따지자 그러면 왼쪽에 들어갈 BST * 오른쪽에 들어갈 BST로 나타낼 수 있다.)
4. DP[n] = DP[n-1] + DP[n-2] + DP[n-2]
5. DP[i][j] = max(DP[i-1][j] , DP[i-1][j-1]) + a[i][j] 
6. DP[i] = max (DP[j]) + 1 (1 <= j < i , a[j] < a[i])
7. DP[i] = min (DP[i-coin[j]) + 1 (1<= j <= n, i>= coin[j], i는 금액, j는 동전의 종류)
8. DP[i][j] = if j >= weight[i] max(DP[i-1][j-weight[i]] + value[i], DP[i-1][j]) else DP[i-1][j] (i번째 보석까지 j의 무게만큼 가능할때 i번째 보석을 가져가는 경우, 가져가지
않는 경우로 나누어 생각하자.)
9. DP[i] += DP[i-j] (1<=j<=4, i>=j, i는 동전들의 합, j는 동전의 종류 8을 만든다 가정할때 1~4까지는 동전 하나만 쓰는 경우의 수를 고려해서 초기값 1로 잡는것은 괜찮은데, 5부터는 불가능)
10. DP[i][j] = if A[i] != B[j] max(DP[i-1][j], DP[i][j-1]) else DP[i-1][j-1] + 1 (문자열 A를 i번째 까지 고려, B를 j번째 까지 고려)
11. LCS를 이용하여 구할 수 있음
12. DP[i][j] = if(A[i] != B[j]) min(DP[i-1][j], DP[i][j-1], DP[i-1][j-1]) + 1 else DP[i-1][j-1] (각 연산에 대해서 경우의 수를 나눠보자)


