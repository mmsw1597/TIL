## 시간복잡도
프로그램의 성능을 평가하는 지표, 즉 코드를 분석하여 코드의 효율성을 확인하는 수식이다.
연산의 횟수를 점근적 표기법을 통하여 추상적으로 표현하면 그것을 시간복잡도라고 부른다.

## 기본연산
int a = 10 과 같은 대입연산은 컴퓨터에서는 많은 연산 과정을 거치더라도 우리는 단순하게 O(1)의 연산을 수행했다고 본다.
이외에도 print()연산, 조건문 연산 등 단순한 연산은 O(1)의 연산을 수행한다고 본다.
보편적으로 컴퓨터는 1초에 1억번의 연산이 가능하다. 따라서 N의 범위에 따라 작성한 알고리즘이 제한시간내에 답을 내는지 확인하는 방법은 아래와 같다.

![image](https://user-images.githubusercontent.com/55936770/175029347-1bb017aa-0d6e-4c7b-8609-eb99fa953125.png)

## 반복문에서의 시간 복잡도
빅 오 표기법에서는 N의 가장 높은 차수만 고려한다. 따라서 O(N^2 + N + 3) = O(N^2)로 표기한다. 또한 상수는 무시한다.
```c
for(int i = 0; i< n; i++)
  x++;
```
위와 같은 반복문은 O(1)연산을 n번 반복하므로 O(N)이다.
```c
for(int i=0; i< n/2; i++)
  x++;
```
  위와 같은 반복문은 O(1)연산을 n/2번 반복하지만, 상수는 무시하므로 O(n)으로 표기한다.
```c
for(int i=0; i<n; i++)
  for(int j=0; j<n; j++)
      x++;

for(int i=0; i<n; i++)
  x++;
  ```
위의 코드는 총 n^2 + n번만큼 반복하지만 가장 높은 차수만 고려하므로 O(N^2)로 표기한다.
```c
for(int i=0; i<n*n; i++)
  for(int k=0; k<=i; k++)
    printf("hello");
  for(int j=n; j>=0; j--)
    printf("bye");
```    
위 코드의 시간복잡도는 우선 맨 바깥쪽 i는 n*n번 연산을 수행하고 k는 i번만큼 반복, j는 n번만큼 반복이므로 n^4 + n^3번 반복한다. 따라서 O(N^4)로 표기한다.
```c
for(int i=0; i<n; i++)
  j=1;
  while(j<i)
    j*=2;
 ```
위 코드의 시간복잡도는 바깥쪽 i는 n번 반복, 안쪽 j는 logi번 반복한다고 할 수 있다. 따라서 nlogn번 연산을 수행한다고 볼 수 있다. 빅오는 O(NlogN)으로 표기한다.

## 재귀함수에서의 시간 복잡도
```c
function A(n)
if(n<0)
  return 0
if(n<=5)
  return A(n-2)
return A(n-1)
```
위 재귀함수에서의 시간복잡도는 우선 n<=5일때 경우를 생각해보자. n<0일때 재귀함수를 탈출하므로 n<=5일때에는 최대 3번까지 반복이 가능하다.
다음으로 맨 아래 재귀함수 호출을 보면 N이 5가 될때까지 감소하다가 5가되면 3번반복하게 된다. 따라서 (n-5) + 3번 반복한다고 볼 수 있다. 
결론적으로 위 코드의 빅 오는 O(n)이 된다.

## 공간복잡도
공간복잡도는 시간복잡도보다 중요도는 낮으나 간단하게만 알고 가도록 하자. 주어진 문제에서 만약 80MB의 공간제한이 주어진다면 변수를 최대 얼마나 선언할 수 있을까?
c++기준 int는 4byte이므로 int형 변수 2천만개를 선언할 수 있고, char는 1byte이므로 8천만개, double은 8byte이므로 1천만개까지 선언이 가능하다.
  
    
    
