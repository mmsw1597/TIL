### 위상정렬
방향성 그래프가 주어지고 각 노드가 하나의 일이라고 할 때, 앞에 일이 끝나야만 뒤의 일이 진행될 수 있는 문제일 경우 어떤 순서로 작업해야 하는지 알려주는 알고리즘이다. <br>
![image](https://user-images.githubusercontent.com/55936770/179976112-bac9e891-67d9-4900-a674-116bbfd71cf0.png)<br>
위 그래프에서 1, 3, 4, 6, 2, 5, 7이 가능한 순서중 하나이며 1, 4, 3, 6, 2, 5, 7도 가능하므로 순서는 유일하다고 할 수 없다. 위상정렬 방법은 크게 2가지로 DFS를 이용한 방법과
in-degree를 이용한 방법이 있다.

### DFS를 이용한 위상정렬
결론부터 말하면 DFS로 탐색하다가 더 이상 진행할 수 없다면(후퇴해야 하면) 그 때, 노드를 기록한다. 그리고 기록한 노드의 역순이 위상정렬의 답이된다. 따라서 stack을 이용하여 
편하게 구현이 가능하다. 중요한 점은 특정 정점에서 DFS를 시작하면 모든 정점을 방문할 수 없을 수도 있다. 따라서 1~n번까지 정점을 순서대로 보면서 아직 방문한 적이 없는 정점에 대해
모두 dfs를 추가적으로 진행해줘야 한다는 것이다. 따라서 시간복잡도는 O(V+E)가 된다.

### In-Degree를 이용한 위상정렬
앞의 일이 끝난 정점은 in-degree가 0이다. 따라서 in-degree가 0인 곳만 시작점이라고 얘기할 수 있다. 그리고 0인 지점의 일을 하고나면 해당 노드를 queue에 넣어준다. 그러고 나서
해당 노드에 연결된 정점의 in-degree를 1 감소시켜준다. 쉽게 말하면 간선을 지우는 것과 같다. 이렇게 되면 in-degree가 0인 지점이 존재할 것이고 다시 위 과정을 반복해주고 최종 결과는
queue에서 나오는 순서와 같다. 시간복잡도는 각 정점과 각 간선을 한번씩 보게 되므로 O(V+E)와 같다. 
