### 크루스컬 알고리즘
MST를 만드는 알고리즘 중 하나인 크루스컬 알고리즘이다. 시작은 간선 중 가중치가 가장 작은 간선부터 찾는 것이다. 가장 작은 가중치를 갖는 간선이 여러개라면 그 중 아무 간선이나 골라도
상관없다. 이런식으로 하다보면 사이클이 생기는 상황이 발생할 수 있다. MST는 트리이므로 사이클이 있어서는 안된다. 이때 활용하는 것이 Union-Find이다. 방법은 특정 간선을 선택하면
두 노드에 union 연산을 수행하고 같은 그룹에 포함시킨다. 만약 사이클이 발생한다면 두 노드가 같은 집합에 속한 상태인 것이니 같은 집합이라면 두 노드를 잇는 간선은 제외한다. <br>

정리하면 간선을 추가할때마다 union()연산을 수행하고 이후 간선을 추가하기전 find()연산을 수행해서 두 노드가 같은 루트노드를 갖는지 확인하고 같으면 추가하지 않고 다를때만 추가한다. 

### 시간 복잡도
간선을 작은 것부터 골라야하니 정렬이 필요하므로 O(ElogE)의 시간이 필요하고 각 간선에 대하여 union-find 연산은 O(logN)이므로 O(ElogN)이다. 따라서 일반적으로 간선이 정점보다 많으므로
O(ElogE)가 된다.

### 의사코드
```c
function kruskal()
    mst = []                       // mst를 담을 배열입니다.
    sort edge[] by length          // 간선을 가중치 기준으로 오름차순 정렬합니다.
    uf = uf_init(|V|)              // uf 배열을 노드의 수 |V|만큼 초기화합니다.

    for E in edge[]                // 각각의 간선에 대해 
        u, v = E                   // 간선을 이루고 있는 두 노드 u, v를 보며
        if find(u) != find(v)      // u, v의 루트 노드가 다른 경우에만
            mst.push(E)            // mst에 해당 간선을 넣어주고
            union(u, v)            // u, v를 같은 루트 노드를 갖도록 만들어줍니다.
    
    return mst
```
