# IP Fragmentation
1. 링크마다 최대 패킷 크기 제한이 존재한다 (MTU)
2. MTU보다 보내려고 하는 패킷이 더 크다면 패킷을 분해해야 한다.
3. 각각의 패킷은 서로 독립적으로 목적지를 향해 이동한다. (서로 다른 경로로 이동할 수 도 있다.)
4. 목적지에서는 분해된 패킷이 원본 패킷으로 조립되어야 한다.
5. 주의할 점은 IP 헤더는 제거되고 남은 데이터 부분을 분해하며 분해된 패킷마다 각각 헤더가 다시 붙는다.

## Fragmentation을 위한 헤더 요소
### 16 bit ID
1. 하나의 패킷이 분리 될 경우 분리된 패킷들은 하나의 공통된 16bit ID를 갖게 된다.
2. 해당 ID는 무작위이다.

### Frag flag
1. flag가 1이라면 자신의 뒤에 이어질 패킷이 더 있다는 뜻이다.
2. flag가 0이라면 자신이 마지막 패킷이라는 뜻이다.
3. 원본 패킷은 flag가 0이고 분해될 경우 맨 마지막 순서의 패킷은 flag가 0이고 이외에는 전부 flag가 1이다.

### Offset
1. 첫 바이트 번호 / 8 을 의미. 즉, 첫번째 분해된 패킷은 0이다.
2. 8로 나누는 이유는 8로 나눌시 비트가 왼쪽으로 3번 이동되고 이는 비트 수를 절약하기 위함.

## 만약 분해된 것중 일부가 손실된다면?
1. Transport Layer가 TCP라면 송신측에서 재전송을 할 것이며 UDP면 드랍할 것이다.
2. 라우터는 재전송 기능이 없다. 송신측에서 다시 원본을 재전송해야 한다.

# ICMP
1. 라우터와 host간에 컨트롤 메시지 전달에 쓰이는 프로토콜.
2. 사용자로 인해 생성된 데이터는 담고 있지 않다.
3. 네트워크 내부에서 여러가지 상황을 리포트하는 용도다.

# IPv6
IPv4와 달리 128bit 주소공간을 사용하는 프로토콜

## Tunneling
1. 만약 IPv4에서 IPv6로 전환을 한다면 과도기 시점에서는 IPv4와 IPv6를 사용하는 라우터가 공존할 것이다.
2. IPv4를 쓰는 라우터는 IPv6 패킷을 이해하지 못한다.
3. 따라서 IPv6 라우터는 다음 라우터가 IPv4라면 IPv6패킷을 통째로 데이터 부분에 담고 IPv4헤더를 달아서 전송해야 원할한 통신이 가능하다.

# Routing Algorithm

## Link State
1. 다익스트라 알고리즘을 사용한다.
2. 모든 라우터들은 현재 네트워크 상황(링크 연결 상황, 링크 가중치)를 알고 있다는 가정하에 쓰이는 알고리즘이다.
3. 따라서 사전에 브로드캐스트 메시지를 날려서 서로의 정보를 알 수 있게 하는 절차가 필요하다. 

## Distance Vecotr
1. 벨만포드 알고리즘을 사용한다. (재귀, 동적계획법)
2. link state와 다르게 모든 네트워크 상황은 알지못하고 이웃한 노드의 정보만 아는 상태여도 동작한다.
3. dx(y) = min{c(x, v) + dv(y)} 공식을 사용한다.
4. x입장에서 dv(y)는 알지못한다. 이 값은 v노드가 x에게 알려줘야한다. 즉, 이웃 노드로부터 받은 c(x, v) + dv(y)값 중 가장 작은 값을 도출하는것.
5. 모든 라우터는 각 노드로 이동하는 비용을 담은 벡터를 갖게 된다.
6. 만약 자신이 이웃 노드로부터 새로운 벡터 메시지를 받거나 자신의 벡터가 변경된다면 업데이트 후 전파한다.
7. 좋은 소식(비용이 낮아지는 경우)은 문제없이 빠르게 전파되고 금방 stable 상태로 된다.
8. 나쁜 소식(비용이 높아지는 경우)은 진동을 일으키며 stable 상태까지 매우 오래걸리게 된다.

### 왜 나쁜 소식에 진동을 일으킬까
1. 가장 빠른 이해는 예제를 보면 된다.
2. 결론부터 말하면 내가 알고 있는 어떤 최단 경로가 사실 나한테 의존하는 경로인데 그걸 최단경로로 선택될때 문제가 된다.
3. 완전 연결 그래프상에서 x, y, z 노드가 있는데 y 노드에서 x노드로 가는 최단경로는 y->x 이고 z노드에서 x노드로 가는 최단 경로는 z->y->x 라고 가정하자.
4. 이때 y->x 경로에 혼잡이 발생하여 비용이 매우 높아졌고 진짜 최단 경로는 y->z->x 인 상태이다.
5. y는 y->x 경로를 택하지 않고 y->z->x 를 선택하게 되지만 사실 현재 벡터 상에선 dz(x)는 z->y->x 인 상황이다. 즉 나로 되돌아오는 경로임
6. 결국 y와 z사이에서 업데이트가 수없이 일어나게 된다. 이는 y->x 비용보다 높아질때까지 반복된다.

### 포이즌 리버스
1. 위 상황을 해결하는 방법
2. 이 문제의 원인은 나한테 전달되는 최단경로 정보중 나를 의존하는 최단경로를 받게되었기 때문
3. 따라서 어떤 경로가 특정 next hop에 의존하고 있다면 그 경로값은 next hop을 제외하고 다른 노드에게는 경로값을 알려주지만 그 next hop에게는 무한대라고 알려주면 해결된다.
