# 프로세스를 생성하고 제어하는 방법
프로세스를 생성하고 제어하려면 운영체제가 어떤 인터페이스를 제공해야 하는가? 유용성, 편리성, 성능을 위해서 어떻게 인터페이스를 설계해야하는가

# PID
1. 프로세스 식별자
2. 특정 프로세스를 대상으로 작업을 해야할 경우 프로세스를 지칭하기 위해 사용된다.

# fork()
1. 프로세스 생성을 위해 운영체제가 제공하는 시스템 콜
2. 생성한 프로세스를 부모, 생성된 프로세스를 자식 프로세스라 한다.
3. 자식 프로세스는 부모 프로세스의 복제본이라고 할 수 있다. (완전히 동일하지는 않다.)
4. 부모와 자식의 차이는 주소공간, 레지스터, PC값에서 차이가 있다.
5. fork 함수의 리턴값도 다르다. 부모의 경우는 자식의 PID가 리턴되고 자식은 0이 리턴된다. 이는 부모와 자식 프로세스가 서로 다른 코드를 수행하게 해준다.
6. fork가 리턴되고 나서는 어느 프로세스가 먼저 실행될지는 알 수 없다. 이는 CPU 스케줄러가 결정한다.

# wait()
1. 부모 프로세스가 자식 프로세스의 종료를 대기하게끔 해주는 시스템 콜
2. 부모에서 wait을 호출하면 자식의 종료까지 자신의 실행을 잠시 중단시킨다.
3. 자식이 종료되면 wait은 리턴한다.
4. 이는 부모와 자식의 실행 순서를 자식이 먼저 실행되도록 하는데에 의미가 있다.

# exec()
1. 이 시스템 콜은 자기 자신이 아닌 다른 프로그램을 실행해야 할때 사용된다.
2. fork와는 다르게 복사본을 생성하지 않는다. 
3. exec에게 실행 파일 이름과 인자를 주게되면 해당 실행 파일 코드와 정적데이터를 읽어들여 현재 실행중인 프로세스의 코드와 정적 데이터 부분을 덮어쓴다.
4. 즉, 새로운 프로세스는 생성하지 않는다. 현재 프로세스가 다른 프로세스로 대체되는 것이다.

# fork와 exec를 분리한 이유
1. Unix의 쉘을 떠올려보자.
2. 쉘은 사용자가 명령어를 입력하면 fork를 호출하여 새로운 자식 프로세스를 만든다.
3. 부모는 wait을 호출하여 자식을 기다린다.
4. 자식은 exec를 호출하여 프로그램을 실행시킨다.
5. 자식이 종료되면 부모의 wait이 리턴하게되고 다시 프롬프트를 출력하고 다음 명령어를 기다린다.
6. fork와 exec를 분리하여 fork를 한 후 exec가 실행되기전 프로그램의 환경을 설정하고 다양한 기능을 준비할 수 있게 된다.
7. 이처럼 fork와 exec의 분리는 프로세스를 생성하고 조작하는 강력한 방법이다.
