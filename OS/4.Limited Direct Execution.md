# CPU 가상화를 위해서 해결해야 할 문제
1. 시스템에 과중한 오버헤드를 주지 않으면서 가상화를 구현할 수 있는가
2. CPU에 대한 통제를 유지하면서 프로세스를 효율적으로 실행할 수 있는 방법이 무엇인가

# Limited Direct Execution
1. 직접 실행이라는 말은 프로그램을 CPU상에서 직접 실행시킨다는 의미이다.
2. 직접 실행을 한다면 문제점이 있다. 첫째로 프로그램이 운영체제가 원치않은 일을 할때 어떻게 해야하는가
3. 두번째로 운영체제는 프로그램의 실행을 중단시키고 다른 프로세스로 어떻게 전환시킬 수 있는가. 즉, 시분할 기법을 어떻게 구현할 것인가
4. 이 두 문제를 해결하기 위해 제한적이라는 말이 붙은 것이다. 프로그램의 실행에 제한을 두면서 CPU 상에서 직접 실행을 시킨다는 의미다.

# 제한된 연산
1. 프로세스가 디스크 입출력 요청이나 메모리나 시스템 자원에 대한 추가할당을 요청하는 요청은 운영체제 입장에서 마음대로 허가할 수 없다.
2. 이를 위해 하드웨어에게 사용자 모드, 커널 모드를 도입했다. 
3. 사용자 모드에서는 코드가 일부 자원을 요청하거나 입출력 요청을 할 수 없게 제한한다.
4. 커널 모드는 사용자 모드에 대비되는 모드로 모든 특수한 명령어를 허가한다.

# 시스템 콜
1. 그렇다면 프로세스가 특권 명령어를 실행해야 할 때는 어떻게 해야하는가
2. 현대 하드웨어는 사용자 프로세스에게 시스템 콜을 제공한다. 이러한 기능에는 파일 시스템 접근, 프로세스 생성 및 제거, 프로세스간의 통신 등이 해당한다.
3. 시스템 콜을 실행하기 위해서는 프로그램은 trap 명령어를 실행해야 한다. trap 명령어는 커널 안으로 분기하는 동시에 커널 모드로 전환한다.
4. 모든 요청이 완료되면 운영체제는 return-from-trap 명령어를 실행한다. 이는 사용자 모드로 전환하고 호출한 사용자 프로그램으로 리턴한다.

# trap
1. trap 명령어를 수행할 때, 호출한 프로세스의 필요한 레지스터들을 저장할 필요가 있다.
2. 이는, return from trap 명령어를 실행할때 사용자 프로세스로 제대로 리턴하기 위함이다.
3. PC, flag 등 몇 개의 레지스터들을 각 프로세스의 커널 스택에 저장한다.
4. 그리고 return from trap 명령어가 실행되면 스택에서 pop 하여 사용자 프로그램의 실행을 재개한다.

# trap table
1. trap 발생 시 운영체제 코드의 어디를 실행할 지 어떻게 알 수 있는가
2. 커널은 부팅 시 trap table을 만들고 이를 이용하여 시스템을 통제한다. 
3. 운영체제는 특정 명령어를 사용해서 하드웨어에게 트랩 핸들러의 위치를 알려준다. 이는 하드웨어에게 예외 사건이 일어났을때 어떤 코드를 실행해야 하는지 알려주는 것이다.
4. 트랩 테이블은 사용자 프로그램에게 쉽게 수정이 되지 않도록 주의가 필요하다.

# 프로세스 간 전환
프로세스가 실행 중이라는 의미는 운영체제는 실행 중이지 않다라는 의미다. 그렇다면 프로세스가 실행 중일때 어떻게 프로세스를 전환할 수 있는가

## 협조 방식
1. 이 방식은 사용자 프로세스가 비정상적인 행동을 하지 않는다고 가정한다.
2. 즉, 운영체제는 사용자 프로세스가 다른 프로세스를 위해 CPU를 반납할 것이라고 믿는다.
3. 프로세스가 시스템 콜을 호출하면 자연스럽게 운영체제한테 제어권이 넘어간다. 이때, 운영체제가 전환을 할지 말지 결정하는 것이다.
4. 이 방식은 수동적이다. 운영체제는 프로세스가 시스템 콜을 호출하거나, 불법적인 연산(0으로 나누기)을 할 때만 제어권을 획득한다.
5. 치명적인 단점이 존재하는데, 프로세스가 무한루프에 걸렸을때는 운영체제가 영영 제어권을 얻지 못한다.

## 비 협조 방식
1. 프로세스가 시스템 콜을 호출하지 않더라도 제어권을 얻을 방법이 필요하다.
2. 타이머 인터럽트가 그 방법 중 하나다. 일정 시간마다 인터럽트를 발생시켜 프로세스를 중단시키고 인터럽트 핸들러를 실행시켜 운영체제에게 제어권을 넘기게 하는 것이다.
3. 운영체제는 타이머 인터럽트 발생 시 실행해야 하는 코드의 주소를 기록해두어야 한다.
4. 인터럽트는 시스템 콜 호출과 유사하게 실행 중이던 프로그램의 상태를 저장해두어야 한다.
5. 인터럽트나 트랩을 처리하는 중에 인터럽트가 발생하는 문제는 나중에 병행성에서 다뤄보자



