# 몇 가지 가정
1. 스케줄링에 대해 이해하기 위해 몇 가지 비현실적인 가정을 하고 시작하자.
2. 모든 작업은 동시에 도착한다.
3. 모든 작업은 OS가 얼마동안 실행되는지 알 수 있다.
4. 모든 작업은 CPU만 사용하는 작업이다.
5. 모든 작업은 같은 시간동안 실행된다.

# 스케줄링 평가 항목
1. turnaround time : 작업이 도착하고나서 작업이 완료할 때 까지 걸리는 시간
2. response time : 작업이 도착하고나서 작업이 시작할 때 까지 걸리는 시간

# 성능과 공정성
1. 성능과 공정성은 스케줄링에서 서로 절충된다.
2. 어느한쪽을 올리게 되면 나머지 한쪽은 포기해야 한다.

# FIFO
1. 말그대로 선입선출 방식이다.
2. 구현은 굉장히 간단하지만 모든 작업이 같은 시간동안 걸리는 가정을 없애면 굉장히 비효율적인 방식이 된다.
3. convoy effect를 발생시킨다.

# Convoy Effect
1. CPU를 많이 쓰지 않는 작업이 CPU를 오랫동안 사용하는 프로세스를 계속 기다리는 현상
2. 마치 마트에서 사탕하나만 결제하면 되는데 앞에 쇼핑카트 한 가득 계산하고 있는 사람을 기다리는 것과 비슷하다.

# SJF
1. 가장 짧게 걸리는 시간을 우선으로 하는 정책 (각 작업이 얼마나 걸릴지 알고 있다는 가정)
2. 모든 작업이 동시에 도착한다면 이 정책은 최적의 정책이라고 할 수 있다.
3. 비선점형 방식이기 때문에 OS는 실행중인 프로세스를 중단시키지 못한다고 가정
4. 동시에 도착하지 않게 되면 길게 걸리는 작업이 먼저올때 convoy effect가 다시 발생할 우려가 있다.

# STCF
1. 선점형 방식의 SJF라고 보면 된다. 도중에 프로세스를 중단시킬 수 있다.
2. 새로운 작업이 도착하게 되면 현재 실행중인 프로세스와 도착한 프로세스의 잔여 시간을 비교하고 짧은 것을 먼저 실행시키게 한다.
3. 하지만 만약 같은 시간을 갖는 작업이 동시에 도착한다면 마지막에 걸리는 프로세스는 공정성을 잃어버리게 된다.(응답시간이 느리다)
4. 특히나, 최근 시분할 컴퓨터에서는 응답시간이라는 평가 기준이 중요하게 되어 해당 스케줄링 방식이 최적이라고는 할 수 없다.

# Round Robin
1. 모든 작업들은 일정 시간동안만 작업을 수행할 수 있게 되고 그 시간을 모두 소진하면 다른 작업에게 CPU를 양보하는 방식
2. 일정시간을 time slice 라고 한다.
3. time slice를 구현하기 위해선 time slice의 길이는 타이머 인터럽트 주기의 배수여야 한다.
4. 해당 정책은 응답시간을 기준으로 봤을때 최적의 정책이라고 볼 수 있다. 다시말해 매우 공정하다.
5. 하지만 반환시간에 있어서는 FIFO 보다도 안좋을 수 도 있고 어찌보면 최악의 정책이다.

## time slice의 길이 선정
1. 너무 길면 공정성을 잃게 된다.
2. 너무 짧으면 문맥 교환의 전체에서 차지하는 비용이 매우 높아진다.
3. 따라서 적절한 time slice 길이를 선정하는 것이 중요하다.

# 입출력 연산 고려
1. 모든 프로그램이 CPU만 사용한다는 가정을 없애보자. 모든 프로그램은 입출력 작업을 수행한다고 가정.
2. 입출력 작업은 CPU를 사용하지 않으므로 해당 작업동안 다른 프로세스에게 CPU를 양보할 필요가 있다.
3. STCF를 사용한다고 생각하자. 작업 A는 총 50ms, 10ms마다 10ms의 입출력 작업 수행. 작업 B는 총 50ms의 작업을 수행한다고 가정
4. 작업 A를 10ms의 작은 작업으로 분할하면 작은 단위의 10ms 작업을 끝내고 CPU를 B에게 양보하고 다시 작업 A를 하고.. 이런 방식이다.
5. 이렇게 하면 시스템 사용률을 향상시킬 수 있다.

# 현실에서는?
1. 스케줄러가 모든 작업의 실행 시간을 안다는 것은 비현실적인 가정이다.
2. 현실에서 SJF나 STCF를 어떻게 구현할 수 있을까?
3. 반환시간 기준 최악인 RR 스케줄러의 아이디어를 어떻게 쓸 수 있을까?
