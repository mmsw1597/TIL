### 객체
객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조다. 객체는 0개 이상의 프로퍼티로 구성된 집합이며 프로퍼티는 키와 값으로 구성된다.
함수도 프로퍼티 값으로 사용할 수 있고, 객체의 함수와 일반 함수를 구분하기 위해 객체의 함수는 메서드라고 부른다. 정리하면 프로퍼티는 객체의 상태를 나타내는 값이고
메서드는 프로퍼티를 참조하고 조작할 수 있는 동작이다.

### 객체 생성
객체 생성은 여러가지가 있지만 이중 가장 보편적으로 사용하는 방법은 객체 리터럴을 사용하는 방법이다. 예시는 아래와 같다.
```java
var person = {
  name: 'Lee',
  sayHello: function() {
    console.log(`Hello My name is ${this.name}.`);
    }
  };
console.log(typeof person); //object
console.log(person); //{name : "Lee", sayHello: f}
```
중괄호 내에 아무것도 정의하지 않으면 빈 객체가 생성된다.

### 프로퍼티
프로퍼티를 나열할 때에는 쉼표로 구분한다. 프로퍼티 키는 문자열 또는 심벌 값, 심지어 빈 문자열로도 사용가능하다. 프로퍼티 값은 자바스크립트 내에 모든 값을 사용할 수 있다.
프로퍼티 키의 경우 네이밍 규칙을 무조건 따라야 하는 것은 아니다. 하지만 네이밍 규칙을 따르지 않는 키는 이름에 반드시 따옴표를 사용해야한다.
```java
var person = {
  firstName: 'park',
  'last-name': 'Lee'
};
```
가급적이면 네이밍 규칙을 준수하는 키 이름을 지정하는 것이 좋다. 만약 숫자 리터럴로 키 이름을 지정하면 암묵적 타입 변환을 통해 문자열로 변환 된다.
var, function같은 예약어도 사용가능하나 절대 권장하지 않고, 중복된 키 이름도 사용가능하고 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어 씌운다.
에러를 발생시키지 않으므로 이 또한 권장하지 않는다. 프로퍼티는 대괄호를 이용하여 변수를 통해 동적으로 키를 생성이 가능하다 예시는 아래와 같다.
```java
var obj = {};
var key = 'hello';

obj[key] = 'world'; //hello라는 키에 world라는 값의 프로퍼티가 추가된다.
```
### 프로퍼티 접근
프로퍼티 접근 방법은 크게 2가지로 마침표를 이용한 접근방법과 대괄호를 이용한 접근 방법이 있다.
```java
var person = {
  name: 'Lee'
};

console.log(person.name);
console.log(person['name']);
```
주의할 점은 대괄호를 이용할때에는 반드시 따옴표를 감싼 문자열이어야 한다. 만약 객체 내에 존재하지 않는 프로퍼티에 접근시 undefined를 반환한다. 에러를 발생시키지 않는 것에
주의하자. 또하나, 만약 키가 네이밍 규칙을 준수하지 않는다면 무조건 대괄호 표기법을 사용해야만 한다. 

### 프로퍼티 동적 생성
자바스크립트에서는 존재하지 않는 프로퍼티에 값을 할당하면 동적으로 생성되어 객체에 추가된다.
```java
var obj = {};

obj.age = 20; //age 프로퍼티 생성
```

### 프로퍼티 삭제
delete 연산자를 이용하여 프로퍼티를 삭제 가능하다.
```java
var person = {
  name: 'Lee'
};

delete person.name;
```
만약 삭제하려는 프로퍼티가 존재하지 않는 경우 무시한다. 에러를 발생시키지 않는다.

### ES6에서 추가된 객체 리터럴 확장 기능
* 프로퍼티 축약 표현<br>
프로퍼티 값으로 변수를 사용하는 경우 키와 변수 이름이 동일할때, 프로퍼티 키를 생략할 수 있다. 아래와 같다.
```java
let x = 1, y = 2;

const obj = {x, y};
```
* 계산된 프로퍼티 이름<br>
ES5에서는 프로퍼티 이름을 문자열끼리의 계산으로 생성하려면 객체 리터럴 외부에서 대괄호를 이용하여 생성해야만 했다. ES6에서는 리터럴 내부에서도 가능하다. 아래와 같다.
```java
const prefix = 'prop';
let i = 0;

const obj = {
  [`${prefix}-${++i}`]: i
};
```
* 메서드 축약 표현<br>
ES6에서는 function키워드를 생략가능하다.
```java
const obj = {
  sayHi(){
    console.log('Hi!');
  }
};
```

### 생성자 함수에 의한 객체 생성
```java
const person = new Object();

person.name = 'Lee';
person.sayHello = function(){
  console.log('Hi! i'm ' + this.name);
};
```
new 연산자와 함께 호출하여 객체를 생성하는 함수를 생성자 함수라고 한다. 

### 객체 리터럴에 의한 객체 생성의 문제점
객체 리터럴로 객체 생성 시 한번에 하나의 객체만 생성 가능하다 따라서 동일한 프로퍼티를 갖는 객체를 여러개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하므로
비효율적이다. 예를 들어 프로퍼티 구조가 같은 객체에서 프로퍼티 값은 다를 수 있지만 메서드는 내용이 동일한 경우가 일반적이다. 따라서 객체 리터럴로 생성할 경우 
같은 메서드를 생성할때마다 매번 기술해야한다. 이를 막기 위해 생성자 함수를 사용하는 것이다.

### 생성자 함수와 일반 함수
자바스크립트에서 일반 함수와 생성자 함수의 차이점은 형식적으로 정해진 것이 없다. 따라서 일반함수에 new 연산자와 함께 호출해도 생성자 함수로 동작한다.
반대로 new 연산자 없이 생성자 함수를 호출하면 일반 함수로 동작한다.

### 함수의 내부 메서드
함수는 객체이지만 일반 객체와 다르게 호출할 수 있다고 하였다. 일반 객체의 내부 슬롯과 내부 메서드는 물론, 함수 객체만을 위한 [[Call]], [[Construct]] 같은 내부 메서드를
추가로 갖고 있다. 함수가 일반 함수로서 호출되면 [[Call]]이 호출되고, new 연산자와 함께 생성자 함수로 호출되면 [[Construct]]가 호출된다.<br>
이때 함수는 [[Call]]은 무조건 가지지만, [[Construct]]는 모든 함수가 가지진 않는다. [[Construct]]를 갖지 않는다는 이야기는 생성자 함수로서 호출할 수 없다는 이야기다.
[[Construct]]가 없는 함수를 new 연산자와 함께 호출하면 에러가 발생한다. constructor와 non-constructor의 구분은 다음과 같다.
* constructor <br>
함수 선언문, 표현식, 클래스
* non-constructor <br>
메서드(무조건 ES6 메서드 축약 표현을 사용한 메서드 여야함), 화살표 함수

### new.target
생성자 함수와 일반 함수를 구분하기 위한 연산자이다. 함수 내에 사용하면 해당 함수가 new 연산자와 함께 호출된 것인지 아닌지를 판별가능하다.
생성자 함수로서 호출되면 new.target은 함수 자기 자신을 가리키고, 일반 함수로서 호출되면 undefined가 된다. 이를 이용하여 실수로 생성자함수를 new없이 호출해도
생성자 함수로 호출되게끔 안전한 코딩이 가능하다.













