### 클래스
프로토타입의 문법적 설탕이라고 불리는 클래스 문법이지만 실제로 몇가지 차이점이 있다. 따라서 새로운 객체 생성 메커니즘이라고 보는 것이 타당하다.

### 클래스 메서드
1. 프로토타입 메서드
2. 정적 메서드
3. constructor

### 생성자함수와의 차이점
1. 클래스는 new 없이 호출하면 에러가 발생한다.
2. 암묵적으로 클래스 내부에서는 strict mode가 적용된다 이는 해제할 수 없다.
3. 클래스 내부 메서드는 [[Enumerable]]값이 false다 따라서 열거할 수 없다.

### constructor
인스턴스를 생성하고 초기화하기 위한 특수한 메서드. 일반적으로 이 메서드안에 프로퍼티를 정의한다. 이때 내부의 this는 인스턴스를 가르킨다.

### 프로토타입 메서드
생성자 함수와는 다르게 prototype 프로퍼티에 메서드를 추가하지 않아도 프로토타입 메서드가 된다.

### 정적 메서드
static 키워드를 메서드 앞에 명시하면 정적메서드가 된다. 인스턴스를 생성하지 않아도 호출할 수 있는 메서드이다. 인스턴스로 접근하면 에러가 발생한다.

### 클래스 내부의 메서드 특징
클래스 내부 메서드는 모두 function 키워드를 생략한 축약표현이므로 non-constructor다 따라서 new 연산자를 사용할 수 없다.

### 클래스의 화살표 함수
화살표 함수 내부의 this는 언제나 상위 컨텍스트의 this를 가르킨다. 클래스 내부에서 화살표 함수를 사용해서 화살표 함수 내부의 this가 인스턴스를 가르키게 할 수 있다.

### private 필드
일반적인 프로퍼티는 언제나 public이다. 그런데 접두사로 '#'을 붙이면 private으로 정의되어서 클래스 내부에서만 접근 가능한 프로퍼티가 된다. protected는 JS에서는 없다.
따라서 자손 클래스는 부모 클래스의 '#'이 붙은 프로퍼티에 접근 불가능하다.

### extends 키워드
상속을 가능하게 하는 키워드. 이때 프로토타입 체인은 bird라는 클래스가 animal 클래스를 상속받는다면 bird->bird.prototype->animal.prototype->object.prototype 이렇게 체인이 형성된다.

### super 키워드
자식이 super를 호출하면 부모의 constructor를 호출한다. 이때, 서브클래스가 constructor를 생략안하는 경우 super를 무조건 호출해야하며, super 호출전에는 this를 참조할 수 없다.
또한 반드시 constructor 내부에서 super를 호출해야 한다.


