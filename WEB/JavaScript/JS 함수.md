### 함수 정의
자바스크립트에서 함수를 정의하는 방법은 크게 2가지가 있다. 선언문으로 정의하거나 표현식으로 정의하는 방법이 있다. 이외에 function 생성자 함수와 화살표 함수를 사용하는
방법이 있다. 여기서 생성자 함수는 일반적으로 잘 사용되진 않는다. 

### 함수 리터럴
자바스크립트에서 함수는 객체 타입의 값이다. 따라서 함수도 변수에 할당이 가능하다. 여기서 중요한 점은 함수는 객체라는 것이다.
``` java
var f = function add(x,y){
  return x+y;
};
```
함수 리터럴은 값을 생성하며 그 값은 객체이다. 일반 객체와는 다르게 호출할 수 있다는 것을 유념하자. 또한 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.

### 함수 선언문
``` java
function add(x,y){
  return x+y;
}

add(3,5);

(function bar() { console.log('bar'); } );
bar(); //Error
```
함수 선언문에서 함수의 이름은 생략 불가능이다. 앞서 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이다. 따라서 bar함수를 참조할 수 있는 식별자가 없으므로
에러가 발생한다. 그렇다면 add함수는 왜 호출이 가능할까? 이유는 함수를 선언문으로 정의하면 자바스크립트 엔진이 암묵적으로 함수 이름과 같은 식별자를 생성한다. 거기에
객체를 할당하는 것이다. add로 호출이 가능하다해서 함수 이름으로 호출하는 것으로 착각하면 안된다. 함수 식별자로 호출한 것을 기억하자.

### 함수 표현식
```java
var add = function(x,y) {
  return x+y;
};

console.log(add(2,5));
```
함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.

```java
var add = function foo(x,y) {
  return x+y;
};

console.log(foo(2,5)); //Error
```
함수 이름은 함수 내에서만 유효한 식별자라는 것을 인지하자.

### 함수 호이스팅
```java
console.log(add(2, 5)); //7
console.log(sub(2, 5)); //Error

function add(x,y){
  return x+y;
}

var sub = function (x, y) {
  return x-y;
};
```
모든 선언문이 그렇듯 함수 선언문도 런타임 이전에 자바스크립트 엔진에 의해서 먼저 실행된다. 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성되고
이 객체의 식별자는 함수 이름과 동일하다. 따라서 실제 런타임에서 이미 함수 객체가 생성이 되어 있으므로 함수 선언문 이전에 함수 호출이 가능한 것이다. 이처럼
함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅이라고 한다. <br>
변수 호이스팅과 차이가 있는데, 함수 표현식은 변수 선언문과 마찬가지로 런타임 이전에 undefined로 초기화 된다. 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아니라
변수 호이스팅이 발생한다. 따라서 위 코드에선 sub가 아닌 undefined를 호출한 것이므로 에러가 발생한 것이다. 함수 호이스팅은 함수 호출전 함수를 선언해야 한다는 규칙을 무시하므로
함수 선언문 대신 함수 표현식을 사용할 것을 권장한다.

### 함수 인자
```java
function add(x, y){
  return x+y;
}

console.log(add(2)); //NaN
console.log(add(2,5,7)); //7
```
자바스크립트에서 함수는 매개변수의 개수와 삽입한 인수의 개수가 일치하는지 체크하지 않는다. 이때 인수가 부족해서 할당되지 않는 매개변수의 값은 undefined이고
개수를 초과하여 전달된 인수는 무시되고 arguments 객체의 프로퍼티로 보관된다. 매개변수의 개수는 0개가 이상적이다. 따라서 최대한 적게 만들자.

### 즉시 실행 함수
```java
(function () {
  var a = 3;
  var b = 5;
  return a*b;
}());

res = (function (a,b){
  return a*b;
}(3, 5));
```
정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라고 한다. 즉시 실행 함수는 이름 없는 익명 함수를 사용하는 것이 일반적이다. 즉시 실행 함수는 반드시 그룹 연산자()로 감싸야 한다.
즉시 실행 함수는 변수나 함수 이름의 중복을 방지하는 기능을 한다.

### 콜백 함수
```java
function repeat(n, f){
  for(var i = 0; i< n; i++) {
    f(i);
  }
}
var logAll = function (i) {
  console.log(i);
};

repeat(5, loaAll);

var logOdds = function(i) {
  if(i%2) console.log(i);
};

repeat(5, logOdds);
```
위에서 repeat함수는 함수 f를 매개변수로 외부에서 전달받는다. 이처럼 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 하고, 콜백함수를 외부에서
전달받은 함수를 고차 함수라고 한다.

```java
//repeat을 호출할때마다 함수 객체 생성
repeat(5, function(i) {
  if(i%2) console.log(i);
});

//함수를 한번만 생성
var logOdds = function(i) {
  if(i%2) console.log(i);
};

repeat(5, logOdds); 
```
콜백 함수가 고차 함수 내부에서만 호출된다면 콜백 함수를 함수 리터럴로 정의하고 곧바로 고차 함수로 전달하는 것이 일반적이다. 이때 고차 함수가 호출될 때마다
함수 객체가 생성되므로 고차 함수가 여러번 호출된다면 함수 외부에서 정의한 후 함수 참조를 고차 함수에 전달하는 편이 효율적이다.

### 함수형 프로그래밍
함수가 외부 상태를 변경하면 상태 변화를 추적하기가 어려워진다. 따라서 함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋다.
```java
function changeVal(primitive, obj) {
  primitive += 100;
  obj.name = 'Kim';
}

var num = 100;
var person = { name: 'Lee'};

changeVal(num person);

console.log(num); //100
console.log(person.name) //Kim
```
함수 인자로 전달받은 원시 값은 변경 불가능하므로 외부 원시 값은 변경되지 않았다. 하지만 객체는 변경 가능한 값이므로 함수 내부에서 변경이 가능하다.
이처럼 함수가 외부 상태를 변경하는 상황은 그다지 바람직하지 않다. 왜냐하면 코드의 복잡성을 증가시키고 가독성을 해치기 때문이다. 이러한 문제 해결 방법 중 하나는
객체를 불변 객체로 만들어 사용하는 것이다. 외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라고 한다. 순수함수를 사용하는 것을 권장한다.

### 일급 객체
다음 조건을 만족하는 객체를 일급 객체라고 한다.
1. 무명의 리터럴로 생성 가능하다. 즉, 런타임에 생성이 가능하다.
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환 값으로 사용할 수 있다. <br>
함수는 위 모든 조건을 만족하므로 일급 객체이다.

### 함수 객체의 프로퍼티
일반 객체와 다르게 함수 객체는 고유의 프로퍼티를 갖는다. arguments, caller, length, name, prototype이 있다. __proto__는 접근자 프로퍼티이며 함수의 고유 프로퍼티는 아니고 Object.prototype 객체의 프로퍼티를 상속 받은 것을 알 수 있다. 

### arguments 프로퍼티
arguments 프로퍼티는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이다. 함수 내부에서 지역 변수처럼 사용된다.
함수 호출시 인수를 매개변수보다 초과해서 호출할 경우 전달한 모든 인수는 arguments 객체에 저장된다. arguments 객체는 length 프로퍼티를 가지며 이는 인수의 개수를 의미한다.
문제는 유사 배열 객체이므로 배열 메서드를 사용할 경우 에러가 발생한다. 따라서 간접 호출을 통해 배열 메서드를 사용해야 하는데 이를 해결하는 것이 ES6의 Rest 파라미터이다.

### length 프로퍼티
선언한 매개변수의 개수를 가리키는 프로퍼티다. 인수의 개수와 다름에 주의하자

### name 프로퍼티
함수 이름을 나타낸다. 익명 함수의 경우 ES5에서는 빈 문자열을 갖고, ES6에서는 함수 객체를 가리키는 식별자를 값으로 갖는다.

### prototype 프로퍼티
생성자 함수로 호출 할 수 있는 함수 객체, 즉 constructor만이 소유하는 프로퍼티다. 

### __proto__ 접근자 프로퍼티
모든 객체가 갖고 있는 [[Prototype]]이라는 내부 슬롯이 있고 이는 상속을 구현하는 프로토타입 객체를 가리킨다. 이 내부슬롯이 가리키는 프로토타입 객체에 접근하기위해 사용하는 
접근자 프로퍼티이다. 












