### 변수 호이스팅
자바스크립트 엔진은 변수 선언과 변수 할당 작업을 구분한다. 변수 선언 작업은 런타임 이전 소스코드 평가 과정에서 진행하고, 변수 할당 작업은 런타임 과정에서 진행된다.
다음 코드를 유심히 보자.
```java
console.log(score);

var score;
```
분명 score변수 선언은 console문 아래에 쓰여있다. ReferenceError가 발생할 것 같지만, 해당 코드는 잘 실행되며 결과는 undefined 값이 출력된다.
이유는 코드가 실행되기 이전 모든 선언문은 먼저 실행된다. 따라서 score의 선언을 먼저 끝내고 이후 런타임 과정에서 score를 출력하므로 위 코드는 문제가 없다.<br>

```java
console.log(score);

var score = 80;
```
다음 코드의 출력 값은 무엇일까? 80이라고 생각할 수 있지만 틀렸다. 왜냐하면 선언과 할당을 구분해야 하기 때문이다. var score = 80; 에서 런타임 이전에 수행되는 작업은
오로지 var score;이다. 할당은 런타임에 인터프리터에 의해서 수행되는 것이다. 따라서 위의 출력 값은 undefined 이다.

### 가비지 콜렉터
자바스크립트에서 변수를 선언 할 때를 생각해보자
```java
var score = 80;
score = 90;
```
실제 메모리에 값이 저장되는 과정을 생각해보자 맨 처음 코드 선언문이 실행되고 나서 메모리 0번지에 undefined가 저장되고 식별자 score는 undefined가 저장되어 있는 메모리 주소를 기억한다. 그러고나서 score에 80값을 할당하면 0번지에 있던 값이 80으로 변하는 것일까? 답은 그렇지 않다. 새로운 임의의 메모리 주소 예를들어 2번지에 80값을 저장하고 score는 2번지를 기억한다. 90으로 재할당하면 마찬가지로 2번지는 잊어버리고 새로운 주소 3번지에 90을 저장하고 score는 3번지를 기억한다. <br><br>
그렇다면 위의 예에서 undefined값과 80값은 어떻게 되는 것일까? 이 두 값은 이제 필요없는 값들이므로 가비지 콜렉터에 의해서 메모리에서 자동 해제된다. 해제되는 시점은 정확히 알 수 없다. 이 처럼 가비지 콜럭터는 메모리 공간을 주기적으로 검사하여 더 이상 사용하지 않는 메모리를 해제하여 메모리 누수를 방지한다.

### 템플릿 리터럴
자바스크립트에서 문자열을 나타날 때, 작은 따옴표를 이용하여 문자열을 나타낸다.
```java
var first = 'string';
```
이때 문자열끼리 연결할 때, '+'연산자를 사용하여 두 문자열을 합칠 수 있다. 하지만 이 방식은 가독성을 떨어트린다. 이를 보완한 것이 템플릿 리터럴이다.<br>
템플릿 리터럴은 문자열을 백틱을 사용해서 나타낸다. 탬플릿 리터럴은 멀티라인, 표현식 삽입, 태그드 탬플릿 등 편리한 문자열 처리 기능을 제공한다.<br>
일반적인 문자열에서는 줄바꿈을 할 때, 단순히 엔터 키를 눌러서는 줄바꿈이 허용되지 않는다. 이때는 개행문자(\n)을 이용해야 줄바꿈이 된다.<br>
그러나 템플릿 리터럴에서는 엔터키로도 줄바꿈을 표현할 수 있다. <br><br>
또한 템플릿은 표현식 삽입 기능을 제공하는데 사용방법은 다음과 같다.
```java
var first = 'fff';
var last = 'ddd';

console.log(`my name is ${first} ${last}.`); // my name is fff ddd
```

### 동적 타이핑
C언어나 자바 같은 경우 타입 체크가 엄격하다. 문자 데이터 타입은 char 변수에만 담을 수 있고, 정수 타입은 int 변수에만 담을 수 있다. 이러한 언어를 정적 타입 언어라고 한다. 반대로 자바스크립트는 동적 타입 언어에 속한다. 이는 변수의 타입이 변수에 할당된 값에 따라 동적으로 변화한다는 의미이다. 다시말해 자바스크립트의 언어는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수 타입은 언제든지 변할 수 있다. <br>
이러한 성질은 개발자에게 편리한 코드작성을 할 수 있게 해준다. 다만 이러한 유연성과 함께 신뢰성이 떨어지는 효과도 보인다. 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려우며 자바스크립트엔진이 암묵적으로 타입을 의도와 다르게 변환할 수 있는 단점이 존재한다. 이를 예방하기 위해서는 무분별한 변수 선언은 지양하고 변수의 유효범위는 최대한 좁게, 전역 변수는 되도록 사용하지 않고, 변수의 네이밍은 심사숙고해서 짓도록 하자.

### 비교 연산자
자바스크립트는 특이하게도 두 변수의 값이 같은지 다른지 판별하는 연산자가 두 종료가 있다. '=='(동등 비교), '==='(일치 비교) 이렇게 두 개가 있는데, 동등 비교는 단순히 값만 비교하고 타입은 비교하지 않는다. 즉 5 =='5'를 true로 간주한다. 동등 비교를 사용했을 때는 개발자 입장에서 예측하기 어려운 결과를 만들어낸다. 따라서 값과 타입 모두 비교하는 일치 비교 연산자를 사용해야 명확하다. 따라서 5 === '5'는 false이다. 주의할 점은 NaN === NaN은 false를 반환한다. NaN은 자신과 일치하지 않는 유일한 값이다. 그리고 특이하게도 자바스크립트는 양의 0과 음의 0이 존재하는데 0 === -0 은 true를 반환한다. 결론은 '=='는 지양하고 '==='를 사용하자. 이런 연산이 추가로 생겨난 이유는 자바스크립트는 동적 타입 언어이기 때문이다.

### 지수연산자
ES7부터 도입된 기능으로 2 ** 2 = 2^2를 의마한다. 음수의 거듭제곱을 표현할 때는 소괄호로 묶도록 하자 (-5) ** 2 또한 지수 연산자는 이항 연산자중 우선순위가 가장 높다.
