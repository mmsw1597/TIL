### 변수 호이스팅
자바스크립트 엔진은 변수 선언과 변수 할당 작업을 구분한다. 변수 선언 작업은 런타임 이전 소스코드 평가 과정에서 진행하고, 변수 할당 작업은 런타임 과정에서 진행된다.
다음 코드를 유심히 보자.
```java
console.log(score);

var score;
```
분명 score변수 선언은 console문 아래에 쓰여있다. ReferenceError가 발생할 것 같지만, 해당 코드는 잘 실행되며 결과는 undefined 값이 출력된다.
이유는 코드가 실행되기 이전 모든 선언문은 먼저 실행된다. 따라서 score의 선언을 먼저 끝내고 이후 런타임 과정에서 score를 출력하므로 위 코드는 문제가 없다.<br>

```java
console.log(score);

var score = 80;
```
다음 코드의 출력 값은 무엇일까? 80이라고 생각할 수 있지만 틀렸다. 왜냐하면 선언과 할당을 구분해야 하기 때문이다. var score = 80; 에서 런타임 이전에 수행되는 작업은
오로지 var score;이다. 할당은 런타임에 인터프리터에 의해서 수행되는 것이다. 따라서 위의 출력 값은 undefined 이다.

### 가비지 콜렉터
자바스크립트에서 변수를 선언 할 때를 생각해보자
```java
var score = 80;
score = 90;
```
실제 메모리에 값이 저장되는 과정을 생각해보자 맨 처음 코드 선언문이 실행되고 나서 메모리 0번지에 undefined가 저장되고 식별자 score는 undefined가 저장되어 있는 메모리 주소를 기억한다. 그러고나서 score에 80값을 할당하면 0번지에 있던 값이 80으로 변하는 것일까? 답은 그렇지 않다. 새로운 임의의 메모리 주소 예를들어 2번지에 80값을 저장하고 score는 2번지를 기억한다. 90으로 재할당하면 마찬가지로 2번지는 잊어버리고 새로운 주소 3번지에 90을 저장하고 score는 3번지를 기억한다. <br><br>
그렇다면 위의 예에서 undefined값과 80값은 어떻게 되는 것일까? 이 두 값은 이제 필요없는 값들이므로 가비지 콜렉터에 의해서 메모리에서 자동 해제된다. 해제되는 시점은 정확히 알 수 없다. 이 처럼 가비지 콜럭터는 메모리 공간을 주기적으로 검사하여 더 이상 사용하지 않는 메모리를 해제하여 메모리 누수를 방지한다.
